package handlelogic

import (
	"fmt"
	"github.com/mroth/weightedrand"
	"nightclub/readconf"
	"os"
	"strconv"
	"nightclub/WriteToFile"
)

func (ag *AutoGenerated) BonusScore() int{
	rewards := ag.Others.BonusModel.Big.Normal.Rewards
	weight := ag.Others.BonusModel.Big.Normal.Weight
	var score int
	var err error
	//按权重获取分数
	chooser, _ := weightedrand.NewChooser(
		weightedrand.Choice{Item: rewards[0], Weight: uint(weight[0])},
		weightedrand.Choice{Item: rewards[1], Weight: uint(weight[1])},
		weightedrand.Choice{Item: rewards[2], Weight: uint(weight[2])},
		weightedrand.Choice{Item: rewards[3], Weight: uint(weight[3])},
		weightedrand.Choice{Item: rewards[4], Weight: uint(weight[4])},
		weightedrand.Choice{Item: rewards[5], Weight: uint(weight[5])},
		weightedrand.Choice{Item: rewards[6], Weight: uint(weight[6])},
		weightedrand.Choice{Item: rewards[7], Weight: uint(weight[7])},
		weightedrand.Choice{Item: rewards[8], Weight: uint(weight[8])},
		weightedrand.Choice{Item: rewards[9], Weight: uint(weight[9])},
	)
	result := chooser.Pick().(string)
	if result == ag.Others.BonusModel.Big.Normal.Rewards[7] {
		score = ag.Others.BonusModel.Mutil.MINI
	} else if result == ag.Others.BonusModel.Big.Normal.Rewards[8] {
		score = ag.Others.BonusModel.Mutil.MINOR
	} else if result == ag.Others.BonusModel.Big.Normal.Rewards[9] {
		score = ag.Others.BonusModel.Mutil.MAJOR
	} else {
		score,err = strconv.Atoi(result)
		if err != nil {
			fmt.Println(err)
		}
	}
	return score
}

func (ag *AutoGenerated) HitRespin(gears [][]int, conf *readconf.ConfigFile) (int, bool) {
	//是否触发respin，返回几个bonus图标中的respin
	bonus := ag.ArrOtherSlots[0].Bonus.Type[0]
	//bonusrollgears := ag.Others.BonusModel.BonusRollGear
	count := 0
	for _, j := range gears {
		for _, jj := range j {
			if jj == bonus {
				count++
			}
		}
	}
	if count >= conf.Hitbonus {
		//fmt.Println(gears, count)
		return count, true
	} else {
		return count, false
	}
}

func (ag *AutoGenerated) Respin(bonusidex int, bonusRollGear map[int][]int, conf *readconf.ConfigFile,f *os.File,grandmap map[string]int) int{
	respincount := conf.RespinCount
	var bonusscoreslist []int
	//bonusscoreslist := make([]int,15)
	//fmt.Printf("bonusscoreslist:%V\n",bonusscoreslist)
	for i := 0; i < respincount; i++ {
		bonustemp := 0
		bonus := ag.BonusBase(bonusidex, bonusRollGear)
		//fmt.Printf("1111111111111bonus%v\n",bonus)
		//fmt.Printf("1111111111111 Respin respincount%v , bonusidex%v\n", i, bonusidex)
		for _, j := range bonus {
			//fmt.Println("Respin", j)
			if j == 22 {
				bonustemp++
			}
		}
		if bonustemp != 0 {
			i = 0
		}
		bonusidex = bonustemp + bonusidex
	}
	/*if bonusidex == len(ag.ArrOtherSlots[0].Gears.Pt96.Base) {
		//所有图标全中bonus得大奖grand
		grand := ag.Others.BonusModel.Mutil.GRAND
		fmt.Printf("grand:^%v\n",grand)
		time.Sleep(time.Second *2)
	}
	 */

	//fmt.Printf("bonusidex:%v\n",bonusidex)
	for i:=0;i<bonusidex;i++{
		bonusscore := ag.BonusScore()
		bonusscoreslist = append(bonusscoreslist,bonusscore)
	}
	respinscores := ag.RespinScore(bonusscoreslist)
	//fmt.Printf("bonusscoreslist:%v\n",bonusscoreslist)
	if len(bonusscoreslist) >= 15 {
		//grand大奖
		grand := ag.Others.BonusModel.Mutil.GRAND
		fmt.Printf("grand:%v\n",grand)
		//time.Sleep(time.Second *10)
		grandscore :=ag.ScoreBase*grand
		grandmap["grand"]++
		WriteToFile.WriteTOFile(f,fmt.Sprintf("grand:%v,grandscore: %v\n",grand,grandscore))
	}
	return respinscores
}
