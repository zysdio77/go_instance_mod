package count

import (
	"chao/lun"
	"encoding/json"
	"fmt"
)
/*
type PrizeNumSum struct {
	Num5 int
	Num4 int
	Num3 int
	Num2 int
}

 */
func Score(scorecfg  map[int][]int, winnumber map[int]int,prizenumsum map[int]map[int]int) int{
	////////////////通过json序列化把结构体转化成map//////////////////
	/*
	b, err := json.Marshal(ag.ScoreCfg)
	if err != nil {
		fmt.Println(err)
	}
	scorecfg := make(map[int][]int, 10)
	err = json.Unmarshal(b, &scorecfg)
	if err != nil {
		fmt.Println(err)
	}
	//m := structs.Map(&a)
	//fmt.Println(m)
	 */
	//scorecfg :=ScorecfgToMap(ag)
	////////////////通过json序列化把结构体转化成map//////////////////
	var scoremax int
	scoremax = 0
	//var scorenumber int
	var scoretmp int
	//var prizenumsum PrizeNumSum
	scoretmp = 0
	for k, v := range winnumber {
		if k == 21||k ==22{
			continue
		}
		//fmt.Println(prizenumsum[k],prizenumsum[k][v])
		prizenumsum[k][v]++
		//fmt.Println(prizenumsum)
		for i, j := range scorecfg {
			if k == i {
				scoretmp = j[v-1]
				if scoretmp >= scoremax {
					scoremax = scoretmp
					//scorenumber = i
				}
				//fmt.Printf("winnum:%v,score:%v\n", i, j[v-1])
			}
		}
	}
	//fmt.Printf("scorenumber:%v,scoremax:%v\n", scorenumber, scoremax)
	return scoremax
}

func ScorecfgToMap(ag *lun.AutoGenerated) map[int][]int {
	////////////////通过json序列化把结构体转化成map//////////////////
	b, err := json.Marshal(ag.ScoreCfg)
	if err != nil {
		fmt.Println(err)
	}
	scorecfg := make(map[int][]int, 10)
	err = json.Unmarshal(b, &scorecfg)
	if err != nil {
		fmt.Println(err)
	}
	//m := structs.Map(&a)
	//fmt.Println(m)
	////////////////通过json序列化把结构体转化成map//////////////////
	return scorecfg
}

func ScoreInit()  {


}