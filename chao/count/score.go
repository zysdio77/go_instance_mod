package count

import (
	"chao/WriteToFile"
	"chao/lun"
	"encoding/json"
	"fmt"
	"os"
	"sort"
	"strconv"
)

/*
type PrizeNumSum struct {
	Num5 int
	Num4 int
	Num3 int
	Num2 int
}

*/
func Score(scorecfg map[int][]int, winnumber map[int]int, prizenumsum map[int]map[int]int) int {
	//记录分数
	var scoremax int
	scoremax = 0
	//var scorenumber int
	var scoretmp int
	//var prizenumsum PrizeNumSum
	scoretmp = 0
	for k, v := range winnumber {
		if k == 21 || k == 22 {
			continue
		}
		//fmt.Println(prizenumsum[k],prizenumsum[k][v])
		//prizenumsum[k][v]++	//记录图标连续出现的次数,prizenumsum是图标号2连续钟次的总次数100的结构(2:5:100)，func ScoreInit初始化的
		prizenumsum[v][k]++ //记录图标连续出现的次数,prizenumsum是中5图标号2次数100的结构(5:2:100),func ScoreInit2初始化的
		//fmt.Println(prizenumsum)
		for i, j := range scorecfg {
			if k == i {
				scoretmp = j[v-1]
				if scoretmp >= scoremax {
					scoremax = scoretmp
					//scorenumber = i
				}
				//fmt.Printf("winnum:%v,score:%v\n", i, j[v-1])
			}
		}
	}
	//fmt.Printf("scorenumber:%v,scoremax:%v\n", scorenumber, scoremax)
	//返回线上的最大分数
	return scoremax
}

func ScorecfgToMap(ag *lun.AutoGenerated) map[int][]int {
	////////////////通过json序列化把结构体转化成map//////////////////
	b, err := json.Marshal(ag.ScoreCfg)
	if err != nil {
		fmt.Println(err)
	}
	scorecfg := make(map[int][]int, 10)
	err = json.Unmarshal(b, &scorecfg)
	if err != nil {
		fmt.Println(err)
	}
	//m := structs.Map(&a)
	//fmt.Println(m)
	////////////////通过json序列化把结构体转化成map//////////////////
	return scorecfg
}

func ScoreInit(ag *lun.AutoGenerated) (map[int]map[int]int, map[int][]int) {
	//////////////////////初始化中奖线总数/////////////////////
	prizenumsum := make(map[int]map[int]int) //中奖总数，例如，1中5共多少次
	scorecfg := ScorecfgToMap(ag)
	for k, v := range scorecfg { //初始化map
		prizenumsum[k] = make(map[int]int)
		for i := 1; i <= len(v); i++ {
			prizenumsum[k][i] = 0
		}
	}
	fmt.Println(prizenumsum)
	return prizenumsum, scorecfg
}
func ScoreInit2(ag *lun.AutoGenerated) (map[int]map[int]int, map[int][]int) {
	//////////////////////初始化中奖线总数/////////////////////
	var prizenumsum = make(map[int]map[int]int) //中奖总数，例如，中5 的图标是2，一共100次 就是(5:2:100)
	scorecfg := ScorecfgToMap(ag)
	for _, v := range scorecfg { //初始化map
		//prizenumsum[k]= make(map[int]int)
		for i := 1; i <= len(v); i++ {
			prizenumsum[i] = make(map[int]int)

			//fmt.Println(prizenumsum)
		}
	}
	fmt.Println(prizenumsum)
	return prizenumsum, scorecfg
}

func PrizeNumSumSort(prizenumsum map[int]map[int]int, file *os.File, linescountsum int, scorecfg map[int][]int, linescorebase float64) { //排序中奖图标总数prizenumsum
	sortkeys := make([]int, 0)
	sortkeys0 := make([]int, 0)
	for k, _ := range prizenumsum {
		sortkeys = append(sortkeys, k)

	}
	for k, _ := range prizenumsum[0] {
		sortkeys0 = append(sortkeys0, k)
	}
	sort.Ints(sortkeys)
	sort.Ints(sortkeys0)
	for _, v := range sortkeys {
		fmt.Println(v, prizenumsum[v], sortkeys0)
		for _, vv := range sortkeys0 {
			if vv == 1 {
				continue
			}
			avg := float64(prizenumsum[v][vv]) / float64(linescountsum) * 100
			avgstr := strconv.FormatFloat(avg, 'f', -1, 64)
			hitscoreCfg := scorecfg[v][vv-1]
			scoreout := hitscoreCfg * prizenumsum[v][vv]
			avgout := float64(scoreout) / float64(linescountsum) / linescorebase * 100
			//fmt.Println(scorecfg[v][vv-1])
			data := fmt.Sprintf("图标 %v 中 %v 的次数为 %v, 平均出现几率: %v%v , 总分(OUT): %v , 平均OUT: %v%v \n", v, vv, prizenumsum[v][vv], avgstr, "%", scoreout, avgout, "%")
			WriteToFile.WriteTOFile(file, data)
		}
	}
}
func PrizeNumSumSort2(prizenumsum map[int]map[int]int, file *os.File, linescountsum int, scorecfg map[int][]int, linescorebase float64) {
	sortkeys := make([]int, 0)
	Reversesortkeys := make([]int,0)
	sortkeys1 := make([]int, 0)
	//sortkeys1 :=make([]int,0)
	for k, _ := range prizenumsum {
		sortkeys = append(sortkeys, k)
	}
	for k, _ := range prizenumsum[1] {
		sortkeys1 = append(sortkeys1, k)
	}
	sort.Ints(sortkeys)
	sort.Ints(sortkeys1)
	fmt.Println(sortkeys,sortkeys1,Reversesortkeys)
	for k,_ := range sortkeys{	//把排序好的切片反过来实现倒序
		Reversesortkeys = append(Reversesortkeys, sortkeys[len(sortkeys)-1-k])
	}
	fmt.Println(sortkeys,sortkeys1,Reversesortkeys)

	for _, v := range Reversesortkeys {
		if v == 1 {
			continue
		}
		fmt.Printf("中%v:\n", v)
		data := fmt.Sprintf("中%v:\n", v)
		WriteToFile.WriteTOFile(file, data)
		for _, vv := range sortkeys1 {
			avg := float64(prizenumsum[v][vv]) / float64(linescountsum) * 100
			avgstr := strconv.FormatFloat(avg, 'f', -1, 64)
			hitscoreCfg := scorecfg[vv][v-1]
			scoreout := hitscoreCfg * prizenumsum[v][vv]
			avgout := float64(scoreout) / float64(linescountsum) / linescorebase * 100
			fmt.Printf("    图标%v，次数%v，平均出现几率: %v%v 总分(OUT): %v , 平均OUT: %v%v\n", vv, prizenumsum[v][vv], avgstr, "%", scoreout, avgout, "%")
			data :=fmt.Sprintf("    图标%v，次数%v，平均出现几率: %v%v 总分(OUT): %v , 平均OUT: %v%v\n", vv, prizenumsum[v][vv], avgstr, "%", scoreout, avgout, "%")
			WriteToFile.WriteTOFile(file, data)
		}

	}

	fmt.Printf("prizenumsum:%v,sortkeys:%v,sortkeys1:%v,Reversesortkeys:%v\n", prizenumsum, sortkeys, sortkeys1,Reversesortkeys)
}
